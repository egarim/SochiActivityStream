# Activity Stream (Agnostic) — C# Library Plan for an LLM Agent Programmer

**Goal:** Build an **agnostic Activity Stream system as a C# library** (no HTTP, no UI, no framework ties).  
Any part of your system can publish/query activities as long as it provides the required DTO data.

This document is written to be handed to an LLM coding agent (e.g., Claude Code) to implement the system end-to-end.

---

## 0) Definition of Done (v1 / MVP)

Deliverables (projects):

1. **ActivityStream.Abstractions**
   - DTOs (canonical contract)
   - Interfaces (service + store + id generator + validation)
   - Result/Errors types

2. **ActivityStream.Core**
   - `ActivityStreamService` implementing `IActivityStreamService`
   - Default validator and normalization
   - Cursor generation/parsing (deterministic pagination)
   - Idempotency handling

3. **ActivityStream.Store.InMemory**
   - Reference store implementing `IActivityStore`
   - Correctness > performance
   - Supports idempotency lookups + query filtering + cursor pagination

4. **ActivityStream.Tests**
   - Validation tests
   - Idempotency tests
   - Pagination correctness tests
   - Query filter tests

Optional later (NOT required for v1):
- `ActivityStream.Store.Postgres`
- `ActivityStream.Serialization` (custom `System.Text.Json` converters, if needed)
- Benchmarks

Success criteria:
- All tests green
- Deterministic ordering + cursor pagination with no duplicates or gaps
- Idempotency works as specified
- Zero dependencies on web/UI frameworks

---

## 1) Core Principles

### 1.1 One canonical activity envelope
All activity types (ERP events, logs, user posts, AI events, etc.) share the **same envelope**.

### 1.2 Universal entity references
Anything in the system can be addressed by an `EntityRefDto` as long as it provides:
- `Kind`
- `Type`
- `Id`

### 1.3 Storage-agnostic
The library does not assume Postgres, SQL Server, etc. Storage is via `IActivityStore`.

### 1.4 Append-only mindset
Activities are typically created and queried; edits/deletes are out of scope for v1.

---

## 2) Canonical DTOs (v1)

> DTOs must be **plain** (no persistence attributes) and live in `ActivityStream.Abstractions`.

### 2.1 EntityRefDto (Universal Pointer)

```csharp
public class EntityRefDto
{
    /// <summary>
    /// Broad category: user | service | system | object | ai | tenant | etc
    /// </summary>
    public required string Kind { get; set; }

    /// <summary>
    /// Concrete type: User | Invoice | Project | Agent | Build | etc
    /// </summary>
    public required string Type { get; set; }

    /// <summary>
    /// Identifier within the type.
    /// </summary>
    public required string Id { get; set; }

    /// <summary>
    /// Optional human label.
    /// </summary>
    public string? Display { get; set; }

    /// <summary>
    /// Optional metadata (never required for identity).
    /// Keep as Dictionary<string, object?> for flexibility.
    /// </summary>
    public Dictionary<string, object?>? Meta { get; set; }
}
```

**Equality Contract:** Two `EntityRefDto` are equal when `Kind`, `Type`, and `Id` match using:
- **Trimming**: leading/trailing whitespace is removed  
- **Case-insensitive**: `OrdinalIgnoreCase` comparison for all three fields

This policy is shared with `RelationshipService` for consistency.

### 2.2 ActivityVisibility

```csharp
public enum ActivityVisibility
{
    Public = 0,
    Internal = 1,
    Private = 2
}
```

### 2.3 ActivitySourceDto

```csharp
public class ActivitySourceDto
{
    /// <summary>
    /// Producer/system name: erp | ci | importer | ai-agent | etc
    /// </summary>
    public string? System { get; set; }

    /// <summary>
    /// Correlation id for tracing across systems.
    /// </summary>
    public string? CorrelationId { get; set; }

    /// <summary>
    /// Dedup key (unique per tenant + system).
    /// If present along with System, Publish must be idempotent.
    /// </summary>
    public string? IdempotencyKey { get; set; }
}
```

### 2.4 ActivityDto (Canonical Envelope)

```csharp
public class ActivityDto
{
    /// <summary>
    /// Activity id. Optional on publish; generated by service if missing.
    /// ULID recommended for time-ordering.
    /// </summary>
    public string? Id { get; set; }

    /// <summary>
    /// Required partition key. Required even if single-tenant today.
    /// </summary>
    public required string TenantId { get; set; }

    /// <summary>
    /// Required activity type key: status.posted | invoice.paid | build.completed | etc
    /// </summary>
    public required string TypeKey { get; set; }

    /// <summary>
    /// When the activity actually occurred.
    /// </summary>
    public required DateTimeOffset OccurredAt { get; set; }

    /// <summary>
    /// When stored in the activity stream. Service should set if default.
    /// </summary>
    public DateTimeOffset CreatedAt { get; set; } = default;

    /// <summary>
    /// Required. Who/what caused the activity.
    /// </summary>
    public required EntityRefDto Actor { get; set; }

    /// <summary>
    /// Optional owner grouping (e.g., tenant/project/user timeline owner).
    /// </summary>
    public EntityRefDto? Owner { get; set; }

    /// <summary>
    /// Related entities (used for timelines/indexing).
    /// </summary>
    public List<EntityRefDto> Targets { get; set; } = new();

    /// <summary>
    /// Visibility (default Internal).
    /// </summary>
    public ActivityVisibility Visibility { get; set; } = ActivityVisibility.Internal;

    /// <summary>
    /// Optional human summary (recommended).
    /// </summary>
    public string? Summary { get; set; }

    /// <summary>
    /// Required type-specific payload. Can be empty object.
    /// Use object to allow heterogeneous activity types in one stream.
    /// </summary>
    public required object Payload { get; set; }

    /// <summary>
    /// Optional producer metadata and idempotency.
    /// </summary>
    public ActivitySourceDto? Source { get; set; }

    /// <summary>
    /// Optional tags for filtering/search.
    /// </summary>
    public List<string> Tags { get; set; } = new();
}
```

### 2.5 ActivityQuery (Read filters)

```csharp
public class ActivityQuery
{
    public required string TenantId { get; set; }

    public string? TypeKey { get; set; }

    /// <summary>
    /// Optional: filter by actor entity ref.
    /// </summary>
    public EntityRefDto? Actor { get; set; }

    /// <summary>
    /// Optional: filter by target entity ref (matches any target in Targets list).
    /// </summary>
    public EntityRefDto? Target { get; set; }

    public DateTimeOffset? From { get; set; }
    public DateTimeOffset? To { get; set; }

    /// <summary>
    /// Default 50. Hard max 200 (enforced by service).
    /// </summary>
    public int Limit { get; set; } = 50;

    /// <summary>
    /// Cursor for pagination (opaque string to callers).
    /// </summary>
    public string? Cursor { get; set; }
}
```

### 2.6 ActivityPageResult

```csharp
public class ActivityPageResult
{
    public List<ActivityDto> Items { get; set; } = new();
    public string? NextCursor { get; set; }
}
```

---

## 3) Interfaces

### 3.1 IActivityStreamService

```csharp
public interface IActivityStreamService
{
    Task<ActivityDto> PublishAsync(ActivityDto activity, CancellationToken ct = default);

    Task<IReadOnlyList<ActivityDto>> PublishBatchAsync(
        IReadOnlyList<ActivityDto> activities,
        CancellationToken ct = default);

    Task<ActivityPageResult> QueryAsync(ActivityQuery query, CancellationToken ct = default);
}
```

Batch is optional but useful; implement in v1 if easy (just loop + aggregate results).

### 3.2 IActivityStore

```csharp
public interface IActivityStore
{
    Task<ActivityDto?> GetByIdAsync(string tenantId, string id, CancellationToken ct = default);

    Task<ActivityDto?> FindByIdempotencyAsync(
        string tenantId,
        string sourceSystem,
        string idempotencyKey,
        CancellationToken ct = default);

    Task AppendAsync(ActivityDto activity, CancellationToken ct = default);

    Task<IReadOnlyList<ActivityDto>> QueryAsync(ActivityQuery query, CancellationToken ct = default);
}
```

**Note:** Store can either implement cursor semantics directly or return a superset and allow `Core` to apply cursor rules. For v1, store can return filtered items sorted desc and let `Core` apply cursor + limit.

### 3.3 IActivityValidator

```csharp
public interface IActivityValidator
{
    IReadOnlyList<ActivityValidationError> Validate(ActivityDto activity);
}
```

### 3.4 IIdGenerator

```csharp
public interface IIdGenerator
{
    string NewId();
}
```

ULID recommended (you may use a lightweight ULID package OR implement a simple ULID generator). If avoiding external deps, UUID is acceptable in v1 (ordering still primarily by OccurredAt).

---

## 4) Errors & Validation Result

### 4.1 ActivityValidationError

```csharp
public sealed record ActivityValidationError(string Code, string Message, string? Path = null);
```

### 4.2 Validation strategy (v1)
Base validation always enforced:
- TenantId required, non-empty
- TypeKey required, non-empty
- OccurredAt must not be default
- Actor required and must have Kind/Type/Id non-empty
- Payload required (not null)
- Targets: each must have Kind/Type/Id non-empty
- Tags: trim, remove empty tags, cap count
- Summary length cap (e.g., 500 chars)
- TypeKey length cap (e.g., 200 chars)

If validation fails:
- `PublishAsync` throws a domain exception (e.g., `ActivityValidationException`) containing errors OR returns a result type. Pick one and be consistent. For simplicity: throw `ActivityValidationException`.

---

## 5) Core Service Behavior (MVP)

### 5.1 Normalization (before validate)
Service must:
- Trim strings (`TenantId`, `TypeKey`, `Summary`, entity fields)
- Ensure lists are not null
- Remove empty Tags; optionally dedupe tags (case-insensitive)
- Set `CreatedAt = DateTimeOffset.UtcNow` if `CreatedAt == default`
- Generate `Id` if null/empty

### 5.2 Idempotency
If both exist:
- `activity.Source?.System`
- `activity.Source?.IdempotencyKey`

Then `PublishAsync` must:
1. Look up existing via store:
   - `FindByIdempotencyAsync(tenant, system, key)`
2. If found: return it (do not append)
3. Else append and return

If only one is present (system without key or key without system):
- no dedupe; treat as a normal publish

### 5.3 Ordering (canonical)
All queries must return items ordered:
- `OccurredAt DESC`
- tie-breaker `Id DESC`

### 5.4 Cursor pagination (deterministic)
Cursor encodes the last item of the current page so the next query continues “after” it.

Cursor format v1 (opaque to callers):
- Raw string: `"{occurredAt:O}|{id}"`
- Then Base64Url encode it (no padding).

Rules:
- The service returns at most `Limit` items.
- `NextCursor` is set when there are more items beyond the current page.
- Next page excludes items **>=** cursor position (OccurredAt desc, Id desc). It starts strictly after the cursor.

**Edge cases:** multiple items with same OccurredAt must page correctly using Id tie-breaker.

---

## 6) InMemory Store Requirements

Implement `ActivityStream.Store.InMemory` as a correctness-focused reference.

Must support:
- Append
- Idempotency lookup (tenant + system + idempotencyKey)
- Query filtering:
  - tenant (required)
  - typeKey (optional)
  - actor (optional exact match on Kind+Type+Id)
  - target (optional exact match on Kind+Type+Id within Targets)
  - From/To time range (inclusive/exclusive policy: define and test; recommended: From inclusive, To exclusive)
- Return results sorted `OccurredAt desc, Id desc` (or return unsorted and let Core sort; but prefer store returns sorted for test consistency)

Implementation suggestion:
- Maintain per-tenant `List<ActivityDto>` plus locking.
- Maintain idempotency dictionary key: `${tenant}|${system}|${key}` -> activityId.
- Queries can scan and filter; performance not a priority for v1.

---

## 7) Tests (Required)

### 7.1 Validation tests
- Minimal valid activity publishes successfully
- Missing TenantId/TypeKey/OccurredAt/Actor/Payload fails
- Actor missing Kind/Type/Id fails
- Targets with missing fields fail

### 7.2 Id generation tests
- If Id missing, Publish assigns Id
- If CreatedAt default, Publish assigns CreatedAt

### 7.3 Idempotency tests
- Same tenant + same source.system + same idempotencyKey returns same activity (same Id)
- Different tenant does NOT dedupe
- Same key but different system does NOT dedupe
- If system missing or key missing: no dedupe

### 7.4 Pagination tests
- Publish N activities with known OccurredAt patterns
- Query with Limit=K returns K items
- NextCursor not null when more exist
- Next query returns next K items with no overlap, no gaps
- Works when many items share same OccurredAt

### 7.5 Filter tests
- Filter by TypeKey
- Filter by Actor exact ref
- Filter by Target exact ref
- From/To boundaries

---

## 8) Implementation Milestones (Agent Execution Order)

### M0 — Scaffold
- Create solution + projects
- Enable nullable, analyzers
- Add test framework (xUnit recommended)

### M1 — Abstractions
- Implement DTOs exactly as specified
- Implement interfaces and error types

### M2 — Core
- Implement validator + exception
- Implement cursor encode/decode helpers
- Implement `ActivityStreamService` with normalization + validation + id generation + idempotency + query pagination logic

### M3 — InMemory Store
- Implement `IActivityStore`
- Ensure deterministic ordering

### M4 — Tests
- Add all tests from Section 7
- Ensure all green

### M5 — README
- Usage example
- Behavioral guarantees (ordering, cursor, idempotency)
- Notes about extending with Postgres store later

---

## 9) Example Usage

```csharp
var store = new InMemoryActivityStore();
var svc = new ActivityStreamService(
    store: store,
    idGenerator: new UlidIdGenerator(), // or GuidIdGenerator for v1
    validator: new DefaultActivityValidator()
);

var activity = new ActivityDto
{
    TenantId = "acme",
    TypeKey = "invoice.paid",
    OccurredAt = DateTimeOffset.UtcNow,
    Actor = new EntityRefDto { Kind = "user", Type = "User", Id = "u_123", Display = "Jose" },
    Targets =
    {
        new EntityRefDto { Kind = "object", Type = "Invoice", Id = "inv_332", Display = "Invoice #332" }
    },
    Summary = "Invoice #332 paid",
    Payload = new { invoiceNumber = 332, amount = 500m, currency = "USD" },
    Source = new ActivitySourceDto { System = "erp", IdempotencyKey = "inv_332_paid" }
};

var stored = await svc.PublishAsync(activity);

var page = await svc.QueryAsync(new ActivityQuery
{
    TenantId = "acme",
    Limit = 50
});

foreach (var item in page.Items)
{
    Console.WriteLine($"{item.OccurredAt:u} {item.TypeKey} {item.Summary}");
}
```

---

## 10) Non-goals for v1 (explicitly out of scope)
Do NOT implement yet:
- Reactions, comments, attachments
- Notifications
- WebSockets / realtime streaming
- Schema registry per TypeKey (JSON schema validation)
- Full-text search
- Feed materialization per user

These can be added later without breaking the canonical DTO contract.

---

## 11) Notes for future Postgres store (optional hint)
When adding Postgres later, store:
- `ActivityDto` with `Payload` serialized to JSONB
- `Targets` normalized into a separate table for fast object timelines
- Index `(tenantId, occurredAt desc, id desc)`

---
